# Task 06: æµ‹è¯•è¦†ç›–å®Œå–„

**ä¼˜å…ˆçº§**: ğŸŸ¡ ä¸­ä¼˜å…ˆçº§  
**çŠ¶æ€**: â³ å¾…å¼€å§‹  
**é¢„ä¼°å·¥ä½œé‡**: 4-5å°æ—¶  
**è´Ÿè´£äºº**: å¾…åˆ†é…  

## é—®é¢˜æè¿°

å½“å‰é¡¹ç›®æµ‹è¯•è¦†ç›–å­˜åœ¨ä¸è¶³ï¼š

### å‘ç°çš„é—®é¢˜
1. **ç¼ºä¹é›†æˆæµ‹è¯•**:
   - åªæœ‰å•å…ƒæµ‹è¯•ï¼Œç¼ºå°‘ç«¯åˆ°ç«¯æµ‹è¯•
   - æ¨¡å—é—´äº¤äº’æœªå……åˆ†æµ‹è¯•
   - çœŸå®åœºæ™¯è¦†ç›–ä¸è¶³

2. **é”™è¯¯è·¯å¾„æµ‹è¯•ä¸å…¨**:
   - ä¸»è¦æµ‹è¯•æ­£å¸¸æµç¨‹
   - å¼‚å¸¸æƒ…å†µå’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•ä¸è¶³
   - é”™è¯¯æ¢å¤æœºåˆ¶æœªæµ‹è¯•

3. **æ€§èƒ½æµ‹è¯•ç¼ºå¤±**:
   - æ— åŸºå‡†æµ‹è¯•
   - å†…å­˜ä½¿ç”¨é‡æœªç›‘æ§
   - å¹¶å‘æ€§èƒ½æœªéªŒè¯

4. **æµ‹è¯•æ•°æ®ç®¡ç†**:
   - æµ‹è¯•æ•°æ®åˆ›å»ºç¹ç
   - ç¼ºä¹æµ‹è¯•æ•°æ®æ¸…ç†
   - æµ‹è¯•é—´æ•°æ®æ±¡æŸ“

## å½±å“åˆ†æ

- **ä»£ç è´¨é‡**: éšè—çš„bugå¯èƒ½åœ¨ç”Ÿäº§ç¯å¢ƒæš´éœ²
- **é‡æ„ä¿¡å¿ƒ**: ç¼ºä¹å®Œæ•´æµ‹è¯•è¦†ç›–å¯¼è‡´é‡æ„é£é™©é«˜
- **æ€§èƒ½å›é€€**: æ— æ³•åŠæ—¶å‘ç°æ€§èƒ½é—®é¢˜
- **ç»´æŠ¤æˆæœ¬**: æ‰‹åŠ¨æµ‹è¯•å·¥ä½œé‡å¤§

## è§£å†³æ–¹æ¡ˆ

### 1. å®Œå–„æµ‹è¯•ä½“ç³»
```
tests/                    # æµ‹è¯•ç›®å½•é‡ç»„
â”œâ”€â”€ unit/                 # å•å…ƒæµ‹è¯•
â”œâ”€â”€ integration/          # é›†æˆæµ‹è¯•
â”œâ”€â”€ performance/          # æ€§èƒ½æµ‹è¯•
â”œâ”€â”€ fixtures/             # æµ‹è¯•æ•°æ®
â”œâ”€â”€ helpers/              # æµ‹è¯•å·¥å…·
â””â”€â”€ scenarios/            # åœºæ™¯æµ‹è¯•
```

### 2. æµ‹è¯•ç±»å‹åˆ†ç±»
- **å•å…ƒæµ‹è¯•**: å‡½æ•°çº§åˆ«çš„æµ‹è¯•
- **é›†æˆæµ‹è¯•**: æ¨¡å—é—´äº¤äº’æµ‹è¯•
- **ç«¯åˆ°ç«¯æµ‹è¯•**: å®Œæ•´åŠŸèƒ½æµç¨‹æµ‹è¯•
- **æ€§èƒ½æµ‹è¯•**: åŸºå‡†æµ‹è¯•å’Œå‹åŠ›æµ‹è¯•
- **é”™è¯¯æ³¨å…¥æµ‹è¯•**: å¼‚å¸¸åœºæ™¯æµ‹è¯•

## å®æ–½æ­¥éª¤

### Phase 1: æµ‹è¯•åŸºç¡€è®¾æ–½ (1.5å°æ—¶)
1. é‡æ„æµ‹è¯•ç›®å½•ç»“æ„
2. åˆ›å»ºæµ‹è¯•æ•°æ®ç®¡ç†å·¥å…·
3. å®ç°æµ‹è¯•è¾…åŠ©å‡½æ•°
4. è®¾ç½®æµ‹è¯•ç¯å¢ƒéš”ç¦»

### Phase 2: é›†æˆæµ‹è¯• (2å°æ—¶)
1. æ•°æ®åº“é›†æˆæµ‹è¯•
2. å‘½ä»¤æ‰§è¡Œé›†æˆæµ‹è¯•
3. REPLäº¤äº’æµ‹è¯•
4. æ–‡ä»¶å¯¼å…¥å¯¼å‡ºæµ‹è¯•

### Phase 3: æ€§èƒ½å’Œå‹åŠ›æµ‹è¯• (1.5å°æ—¶)
1. æ•°æ®åº“æ“ä½œåŸºå‡†æµ‹è¯•
2. å¤§æ•°æ®é‡æ€§èƒ½æµ‹è¯•
3. å¹¶å‘è®¿é—®æµ‹è¯•
4. å†…å­˜ä½¿ç”¨é‡æµ‹è¯•

## éªŒæ”¶æ ‡å‡†

### è¦†ç›–ç‡è¦æ±‚
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 85%
- [ ] é›†æˆæµ‹è¯•è¦†ç›–ä¸»è¦åŠŸèƒ½æµç¨‹
- [ ] é”™è¯¯è·¯å¾„æµ‹è¯•è¦†ç›– > 70%
- [ ] æ€§èƒ½åŸºå‡†æµ‹è¯•å»ºç«‹

### è´¨é‡è¦æ±‚
- [ ] æµ‹è¯•ç”¨ä¾‹å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§
- [ ] æµ‹è¯•æ•°æ®ç®¡ç†è§„èŒƒ
- [ ] æµ‹è¯•æ‰§è¡Œæ—¶é—´ < 2åˆ†é’Ÿ
- [ ] æµ‹è¯•ç¨³å®šæ€§ > 99%

### åŠŸèƒ½è¦æ±‚
- [ ] è‡ªåŠ¨åŒ–æµ‹è¯•æµç¨‹
- [ ] æµ‹è¯•æŠ¥å‘Šç”Ÿæˆ
- [ ] æŒç»­é›†æˆé›†æˆ
- [ ] æµ‹è¯•æ•°æ®éš”ç¦»

## æµ‹è¯•è®¡åˆ’

### å•å…ƒæµ‹è¯•å¢å¼º
```go
// æµ‹è¯•è¾…åŠ©å‡½æ•°
func setupTestDB(t *testing.T) (*db.DB, func()) {
    tmpDir := t.TempDir()
    testDB, err := db.Open(tmpDir)
    require.NoError(t, err)
    
    return testDB, func() {
        testDB.Close()
    }
}

// é”™è¯¯æ³¨å…¥æµ‹è¯•
func TestDB_GetCF_Errors(t *testing.T) {
    tests := []struct {
        name        string
        cf          string
        key         string
        setup       func(*db.DB)
        expectedErr error
    }{
        {
            name:        "column family not found",
            cf:          "nonexistent",
            key:         "test",
            expectedErr: db.ErrColumnFamilyNotFound,
        },
        {
            name: "key not found",
            cf:   "default",
            key:  "nonexistent",
            setup: func(d *db.DB) {
                // ç¡®ä¿CFå­˜åœ¨ä½†keyä¸å­˜åœ¨
            },
            expectedErr: db.ErrKeyNotFound,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            db, cleanup := setupTestDB(t)
            defer cleanup()
            
            if tt.setup != nil {
                tt.setup(db)
            }
            
            _, err := db.GetCF(tt.cf, tt.key)
            assert.ErrorIs(t, err, tt.expectedErr)
        })
    }
}
```

### é›†æˆæµ‹è¯•ç¤ºä¾‹
```go
func TestEndToEnd_CRUD_Operations(t *testing.T) {
    db, cleanup := setupTestDB(t)
    defer cleanup()
    
    handler := &command.Handler{DB: db, State: &command.ReplState{CurrentCF: "default"}}
    
    // åˆ›å»ºåˆ—æ—
    result := captureOutput(func() {
        handler.Execute("createcf users")
    })
    assert.Contains(t, result, "OK")
    
    // åˆ‡æ¢åˆ—æ—
    handler.Execute("usecf users")
    
    // æ’å…¥æ•°æ®
    result = captureOutput(func() {
        handler.Execute("put user:1 {\"name\":\"Alice\",\"age\":30}")
    })
    assert.Contains(t, result, "OK")
    
    // æŸ¥è¯¢æ•°æ®
    result = captureOutput(func() {
        handler.Execute("get user:1")
    })
    assert.Contains(t, result, "Alice")
    
    // JSONæŸ¥è¯¢
    result = captureOutput(func() {
        handler.Execute("jsonquery name Alice")
    })
    assert.Contains(t, result, "user:1")
    
    // å¯¼å‡ºæ•°æ®
    tmpFile := filepath.Join(t.TempDir(), "export.csv")
    handler.Execute(fmt.Sprintf("export %s", tmpFile))
    
    // éªŒè¯å¯¼å‡ºæ–‡ä»¶
    content, err := os.ReadFile(tmpFile)
    require.NoError(t, err)
    assert.Contains(t, string(content), "user:1")
}
```

### æ€§èƒ½æµ‹è¯•ç¤ºä¾‹
```go
func BenchmarkDB_GetCF(b *testing.B) {
    db, cleanup := setupBenchDB(b)
    defer cleanup()
    
    // é¢„å¡«å……æ•°æ®
    for i := 0; i < 1000; i++ {
        key := fmt.Sprintf("key_%d", i)
        value := fmt.Sprintf("value_%d", i)
        db.PutCF("default", key, value)
    }
    
    b.ResetTimer()
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            key := fmt.Sprintf("key_%d", rand.Intn(1000))
            _, err := db.GetCF("default", key)
            if err != nil {
                b.Error(err)
            }
        }
    })
}

func TestDB_Memory_Usage(t *testing.T) {
    var m1, m2 runtime.MemStats
    
    runtime.GC()
    runtime.ReadMemStats(&m1)
    
    // æ‰§è¡Œå¤§é‡æ“ä½œ
    db, cleanup := setupTestDB(t)
    defer cleanup()
    
    for i := 0; i < 10000; i++ {
        key := fmt.Sprintf("key_%d", i)
        value := strings.Repeat("x", 1000) // 1KB per value
        db.PutCF("default", key, value)
    }
    
    runtime.GC()
    runtime.ReadMemStats(&m2)
    
    memUsage := m2.Alloc - m1.Alloc
    t.Logf("Memory usage: %d bytes", memUsage)
    
    // éªŒè¯å†…å­˜ä½¿ç”¨åœ¨åˆç†èŒƒå›´å†…
    assert.Less(t, memUsage, uint64(50*1024*1024)) // < 50MB
}
```

### é”™è¯¯æ³¨å…¥æµ‹è¯•
```go
func TestErrorRecovery(t *testing.T) {
    tests := []struct {
        name     string
        scenario func(*testing.T, *db.DB)
    }{
        {
            name: "database corruption recovery",
            scenario: func(t *testing.T, db *db.DB) {
                // æ¨¡æ‹Ÿæ•°æ®åº“æŸå
                db.Close()
                // é‡æ–°æ‰“å¼€åº”è¯¥èƒ½æ¢å¤æˆ–ç»™å‡ºæ¸…æ™°é”™è¯¯
            },
        },
        {
            name: "disk full simulation",
            scenario: func(t *testing.T, db *db.DB) {
                // æ¨¡æ‹Ÿç£ç›˜ç©ºé—´ä¸è¶³
                // éªŒè¯é”™è¯¯å¤„ç†
            },
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            db, cleanup := setupTestDB(t)
            defer cleanup()
            tt.scenario(t, db)
        })
    }
}
```

## æµ‹è¯•å·¥å…·å’Œè¾…åŠ©å‡½æ•°

### æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨
```go
type TestDataGenerator struct {
    db *db.DB
}

func (g *TestDataGenerator) CreateUsers(count int) error {
    for i := 0; i < count; i++ {
        key := fmt.Sprintf("user:%d", i+1)
        value := fmt.Sprintf(`{"id":%d,"name":"User%d","age":%d}`, 
            i+1, i+1, 20+i%50)
        if err := g.db.PutCF("users", key, value); err != nil {
            return err
        }
    }
    return nil
}

func (g *TestDataGenerator) CreateTimeSeries(count int) error {
    now := time.Now()
    for i := 0; i < count; i++ {
        timestamp := now.Add(-time.Duration(i) * time.Minute)
        key := fmt.Sprintf("%d", timestamp.Unix())
        value := fmt.Sprintf(`{"timestamp":%d,"value":%f}`, 
            timestamp.Unix(), rand.Float64()*100)
        if err := g.db.PutCF("metrics", key, value); err != nil {
            return err
        }
    }
    return nil
}
```

### æµ‹è¯•æ–­è¨€æ‰©å±•
```go
func AssertJSONEqual(t *testing.T, expected, actual string) {
    var expectedJSON, actualJSON interface{}
    
    err := json.Unmarshal([]byte(expected), &expectedJSON)
    require.NoError(t, err, "expected JSON is invalid")
    
    err = json.Unmarshal([]byte(actual), &actualJSON)
    require.NoError(t, err, "actual JSON is invalid")
    
    assert.Equal(t, expectedJSON, actualJSON)
}

func AssertCSVContains(t *testing.T, csvContent, expectedRow string) {
    lines := strings.Split(csvContent, "\n")
    for _, line := range lines {
        if strings.Contains(line, expectedRow) {
            return
        }
    }
    t.Errorf("CSV does not contain expected row: %s", expectedRow)
}
```

## CI/CD é›†æˆ

### GitHub Actions æ›´æ–°
```yaml
name: Test Coverage

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: 1.21
    
    - name: Install dependencies
      run: make deps
    
    - name: Run unit tests
      run: go test -v -race -coverprofile=coverage.out ./...
    
    - name: Run integration tests
      run: go test -v -tags=integration ./tests/integration/...
    
    - name: Run performance tests
      run: go test -v -bench=. -benchmem ./tests/performance/...
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.out
```

## é£é™©è¯„ä¼°

**ä½é£é™©**
- æµ‹è¯•æ”¹è¿›ä¸å½±å“ç”Ÿäº§ä»£ç 
- å¯ä»¥æ¸è¿›å¼æ·»åŠ æµ‹è¯•ç”¨ä¾‹
- æµ‹è¯•å¤±è´¥ä¸å½±å“åŠŸèƒ½

**æ½œåœ¨é£é™©**
- æµ‹è¯•æ‰§è¡Œæ—¶é—´å¯èƒ½è¿‡é•¿
- æµ‹è¯•æ•°æ®ç®¡ç†å¤æ‚æ€§å¢åŠ 

## åç»­ä»»åŠ¡

- Task 01: é…ç½®ç®¡ç†ï¼ˆæµ‹è¯•é…ç½®ç®¡ç†ï¼‰
- Task 02: æ—¥å¿—ç³»ç»Ÿï¼ˆæµ‹è¯•æ—¥å¿—è¾“å‡ºï¼‰
- Task 03: å‘½ä»¤æ¶æ„ï¼ˆæµ‹è¯•æ–°æ¶æ„ï¼‰

## å‚è€ƒèµ„æ–™

- [Goæµ‹è¯•æœ€ä½³å®è·µ](https://golang.org/doc/tutorial/add-a-test)
- [è¡¨é©±åŠ¨æµ‹è¯•](https://github.com/golang/go/wiki/TableDrivenTests)
- [é›†æˆæµ‹è¯•ç­–ç•¥](https://martinfowler.com/articles/practical-test-pyramid.html)
- [æ€§èƒ½æµ‹è¯•æŒ‡å—](https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go) 